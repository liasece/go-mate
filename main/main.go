package main

import (
	"go/build"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/liasece/go-mate/gogen/writer/repo"
	"github.com/liasece/go-mate/utils"
	"github.com/liasece/gocoder"
	"github.com/liasece/gocoder/cde"
	"github.com/liasece/log"
	"github.com/spf13/cobra"
)

var entityFile string
var entityNames []string

func buildRunner() {
	tmpPaths := make([]string, 0)
	_ = tmpPaths
	tmpFiles := make([]string, 0)
	_ = tmpFiles
	path, entityFileName := filepath.Split(entityFile)
	log.Info("in", log.Any("entityFile", entityFile), log.Any("path", path), log.Any("entityNames", entityNames))
	c := gocoder.NewCode()
	entityFileBaseName := strings.TrimSuffix(entityFileName, ".go")

	fset := token.NewFileSet()
	// 这里取绝对路径，方便打印出来的语法树可以转跳到编辑器
	f, err := parser.ParseFile(fset, entityFile, nil, parser.AllErrors)
	if err != nil {
		log.Error("parser.ParseFile error", log.ErrorField(err))
		return
	}
	_ = f
	// outStructFileName := filepath.Join(entityFileBaseName + "_struct_gen.go")
	outStructFileTmpName := filepath.Join(entityFileBaseName + "_struct_gen.go")

	entityCs := gocoder.NewCode()

	cV := cde.Value("c", nil)
	for _, entity := range entityNames {
		enV := cde.Value("en"+entity, (*repo.RepositoryWriter)(nil))
		entityCs.C(
			enV.AutoSet(cde.Value("", repo.NewRepositoryWriterByObj).Call(cde.Value("pkg."+entity+"{}", nil))),
			cV.Method("C").Call(
				// enV.Method("GetEntityRepositoryStructCode").Call(),
				enV.Method("GetFilterTypeCode").Call(),
				enV.Method("GetUpdaterTypeCode").Call(),
			),
		)
	}

	c.C(
		cde.NoteLine(`+build ignore`),

		cde.NoteLine(`TEMPORARY AUTOGENERATED FILE: easyjson bootstapping code to launch`),
		cde.NoteLine(`the actual generator.`),
		cde.Func("main", nil, nil).C(
			cV.AutoSet(cde.Value("", gocoder.NewCode).Call()),
			entityCs,
			cde.Value("", gocoder.WriteToFile).Call(cde.Value("", outStructFileTmpName), cV, cde.Value(`gocoder.NewToCodeOpt().PkgName("entity")`, nil)),
			// cde.Return(),
		),
	)
	p, err := build.ImportDir(entityFile, build.FindOnly)
	log.Info("build.ImportDir finish", log.Any("p", p))
	pkgs := gocoder.NewDefaultPkgTool()
	pkgPath, err := utils.GetPkgPath(entityFile, false)
	if err != nil {
		log.Fatal("GetPkgPath error", log.ErrorField(err))
	}
	pkgs.SetPkgAlias(pkgPath, "pkg")

	// 打印语法树
	// buffer := &bytes.Buffer{}
	// ast.Fprint(buffer, fset, f, nil)
	// err = ioutil.WriteFile(filepath.Join(filepath.Join(path, "ast.txt")), buffer.Bytes(), 0644)
	// if err != nil {
	// 	log.Error("ioutil.WriteFile error", log.ErrorField(err))
	// }

	mainPath := filepath.Join(path, "main.go")
	gocoder.WriteToFile(mainPath, c, gocoder.NewToCodeOpt().PkgName("main").PkgTool(pkgs))
	// for _, path := range tmpPaths {
	// 	os.RemoveAll(path)
	// }
	// for _, path := range tmpFiles {
	// 	os.Remove(path)
	// }
	{
		execArgs := []string{"run"}
		execArgs = append(execArgs, mainPath)
		cmd := exec.Command("go", execArgs...)

		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		cmd.Dir = path
		if err = cmd.Run(); err != nil {
			log.Fatal("error main run", log.ErrorField(err))
			return
		}
	}
	// os.Remove(mainPath)
}

func main() {
	var buildRunnerCmd = &cobra.Command{
		Use:   "buildRunner",
		Short: "build a go main.go to target entity folder",
		Long:  "",
		Run: func(cmd *cobra.Command, args []string) {
			buildRunner()
		},
	}
	buildRunnerCmd.Flags().StringVarP(&entityFile, "file", "f", "", "The file path of target entity")
	buildRunnerCmd.MarkFlagRequired("file")
	buildRunnerCmd.Flags().StringArrayVarP(&entityNames, "name", "n", nil, "The name list of target entity")
	buildRunnerCmd.MarkFlagRequired("name")

	var rootCmd = &cobra.Command{Use: "app"}
	rootCmd.AddCommand(buildRunnerCmd)
	rootCmd.Execute()
}
